/**
 * @spec P005-bom-inventory-deduction
 * Inventory Reservation Service
 *
 * Purpose: Handles inventory reservation on order placement
 * Uses pessimistic locking to prevent overselling
 *
 * Author: Generated by P005 spec
 * Date: 2025-12-29
 */

package com.cinema.inventory.service;

import com.cinema.inventory.dto.MaterialRequirement;
import com.cinema.inventory.entity.Inventory;
import com.cinema.inventory.entity.InventoryReservation;
import com.cinema.inventory.entity.InventoryReservation.ReservationStatus;
import com.cinema.inventory.exception.InsufficientInventoryException;
import com.cinema.inventory.exception.InsufficientInventoryException.InventoryShortage;
import com.cinema.inventory.exception.InventoryErrorCode;
import com.cinema.inventory.repository.InventoryRepository;
import com.cinema.inventory.repository.InventoryReservationRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.*;

/**
 * Inventory Reservation Service
 *
 * Implements two-phase inventory management:
 * 1. Reservation: Lock inventory on order placement
 * 2. Deduction: Actually deduct inventory on fulfillment (see InventoryDeductionService)
 *
 * Concurrency control: Pessimistic locking (SELECT FOR UPDATE)
 * Transaction isolation: READ_COMMITTED
 *
 * @see InventoryDeductionService
 */
@Service
public class InventoryReservationService {

    private static final Logger logger = LoggerFactory.getLogger(InventoryReservationService.class);

    private final InventoryRepository inventoryRepository;
    private final InventoryReservationRepository reservationRepository;
    private final BomExpansionService bomExpansionService;
    private final BomSnapshotService bomSnapshotService;
    private final com.cinema.inventory.repository.InventoryTransactionJpaRepository transactionRepository;

    public InventoryReservationService(
            InventoryRepository inventoryRepository,
            InventoryReservationRepository reservationRepository,
            BomExpansionService bomExpansionService,
            BomSnapshotService bomSnapshotService,
            com.cinema.inventory.repository.InventoryTransactionJpaRepository transactionRepository
    ) {
        this.inventoryRepository = inventoryRepository;
        this.reservationRepository = reservationRepository;
        this.bomExpansionService = bomExpansionService;
        this.bomSnapshotService = bomSnapshotService;
        this.transactionRepository = transactionRepository;
    }

    /**
     * Reserve inventory for an order
     *
     * Process:
     * 1. Expand BOM to get material requirements
     * 2. Lock inventory rows (SELECT FOR UPDATE)
     * 3. Check available quantity
     * 4. Update reserved_qty
     * 5. Create reservation records
     * 6. Create BOM snapshots
     *
     * @param orderId Order ID
     * @param storeId Store ID
     * @param items Map of SKU ID to quantity
     * @return List of created reservations
     * @throws InsufficientInventoryException if inventory is insufficient
     */
    @Transactional(isolation = Isolation.READ_COMMITTED, rollbackFor = Exception.class, timeout = 30)
    public List<InventoryReservation> reserveInventory(
            UUID orderId,
            UUID storeId,
            Map<UUID, BigDecimal> items
    ) {
        logger.info("Starting inventory reservation for order: {}, store: {}, items: {}",
                orderId, storeId, items.size());

        // Step 1: Expand BOM to calculate material requirements
        List<MaterialRequirement> materials = bomExpansionService.expandBomBatch(items);
        logger.debug("BOM expansion complete. {} unique materials required", materials.size());

        // Step 2 & 3: Check and lock inventory (row-level locking)
        List<InventoryShortage> shortages = new ArrayList<>();
        Map<UUID, Inventory> lockedInventory = new HashMap<>();

        for (MaterialRequirement material : materials) {
            // Lock inventory row (SELECT FOR UPDATE)
            Optional<Inventory> inventoryOpt = inventoryRepository
                    .findByStoreIdAndSkuIdForUpdate(storeId, material.getSkuId());

            if (inventoryOpt.isEmpty()) {
                logger.warn("Inventory record not found for store: {}, SKU: {}", storeId, material.getSkuId());
                shortages.add(new InventoryShortage(
                        material.getSkuId(),
                        material.getSkuName(),
                        BigDecimal.ZERO,
                        material.getQuantity(),
                        material.getQuantity(),
                        material.getUnit()
                ));
                continue;
            }

            Inventory inventory = inventoryOpt.get();
            BigDecimal available = inventory.calculateAvailableForReservation();

            if (available.compareTo(material.getQuantity()) < 0) {
                logger.warn("Insufficient inventory for SKU: {}. Available: {}, Required: {}",
                        material.getSkuId(), available, material.getQuantity());
                shortages.add(new InventoryShortage(
                        material.getSkuId(),
                        material.getSkuName(),
                        available,
                        material.getQuantity(),
                        material.getQuantity().subtract(available),
                        material.getUnit()
                ));
            } else {
                lockedInventory.put(material.getSkuId(), inventory);
            }
        }

        // If any shortages, rollback transaction
        if (!shortages.isEmpty()) {
            logger.warn("Reservation failed due to {} shortages", shortages.size());
            throw new InsufficientInventoryException(shortages);
        }

        // Step 4: Update reserved_qty for all locked inventory
        List<InventoryReservation> reservations = new ArrayList<>();

        for (MaterialRequirement material : materials) {
            Inventory inventory = lockedInventory.get(material.getSkuId());

            BigDecimal currentReserved = inventory.getReservedQty();
            BigDecimal newReserved = currentReserved.add(material.getQuantity());

            inventory.setReservedQty(newReserved);
            inventoryRepository.save(inventory);

            logger.debug("Updated reserved_qty for SKU {}: {} -> {}",
                    material.getSkuId(), currentReserved, newReserved);

            // Step 5: Create reservation record
            InventoryReservation reservation = new InventoryReservation();
            reservation.setOrderId(orderId);
            reservation.setStoreId(storeId);
            reservation.setSkuId(material.getSkuId());
            reservation.setQuantity(material.getQuantity()); // V054 table structure requires this
            reservation.setReservedQuantity(material.getQuantity());
            reservation.setStatus(ReservationStatus.ACTIVE);
            reservation.setNotes("Reserved " + material.getQuantity() + " " + material.getUnit() +
                    " of " + material.getSkuName());

            InventoryReservation saved = reservationRepository.save(reservation);
            reservations.add(saved);
        }

        // Step 6: Create BOM snapshots
        List<UUID> skuIds = new ArrayList<>(items.keySet());
        bomSnapshotService.createSnapshots(orderId, skuIds);

        logger.info("Reservation complete for order: {}. Reserved {} components",
                orderId, reservations.size());

        return reservations;
    }

    /**
     * Release reservation (cancel order)
     *
     * @param orderId Order ID
     * @return Number of reservations released
     */
    @Transactional(isolation = Isolation.READ_COMMITTED, rollbackFor = Exception.class)
    public int releaseReservation(UUID orderId) {
        logger.info("Releasing reservations for order: {}", orderId);

        List<InventoryReservation> activeReservations = reservationRepository
                .findByOrderIdAndStatus(orderId, ReservationStatus.ACTIVE);

        if (activeReservations.isEmpty()) {
            logger.warn("No active reservations found for order: {}", orderId);
            throw new RuntimeException(InventoryErrorCode.INV_NTF_001.getMessage());
        }

        int releasedCount = 0;
        List<com.cinema.inventory.entity.InventoryTransaction> transactions = new ArrayList<>();

        for (InventoryReservation reservation : activeReservations) {
            // Lock inventory row
            Optional<Inventory> inventoryOpt = inventoryRepository
                    .findByStoreIdAndSkuIdForUpdate(reservation.getStoreId(), reservation.getSkuId());

            if (inventoryOpt.isPresent()) {
                Inventory inventory = inventoryOpt.get();
                BigDecimal currentReserved = inventory.getReservedQty();
                BigDecimal newReserved = currentReserved.subtract(reservation.getReservedQuantity());

                if (newReserved.compareTo(BigDecimal.ZERO) < 0) {
                    newReserved = BigDecimal.ZERO;
                }

                inventory.setReservedQty(newReserved);
                inventoryRepository.save(inventory);

                logger.debug("Released reserved_qty for SKU {}: {} -> {}",
                        reservation.getSkuId(), currentReserved, newReserved);

                // Generate RESERVATION_RELEASE transaction log (T053)
                com.cinema.inventory.entity.InventoryTransaction transaction =
                        new com.cinema.inventory.entity.InventoryTransaction();
                transaction.setStoreId(reservation.getStoreId());
                transaction.setSkuId(reservation.getSkuId());
                transaction.setTransactionType(com.cinema.inventory.entity.InventoryTransaction.TransactionType.RESERVATION_RELEASE);
                transaction.setQuantity(BigDecimal.ZERO); // No on_hand_qty change, only reserved_qty
                transaction.setQuantityBefore(inventory.getOnHandQty());
                transaction.setQuantityAfter(inventory.getOnHandQty());
                transaction.setRelatedOrderId(orderId);
                transaction.setOperatorId(UUID.randomUUID()); // TODO: Get actual operator ID
                transaction.setNotes("Released reservation for cancelled order " + orderId +
                        ", released_qty: " + reservation.getReservedQuantity());
                transactions.add(transaction);
            }

            // Update reservation status
            reservation.markAsCancelled();
            reservationRepository.save(reservation);
            releasedCount++;
        }

        // Save transaction logs in batch
        if (!transactions.isEmpty()) {
            transactionRepository.saveAll(transactions);
            logger.debug("Generated {} RESERVATION_RELEASE transaction logs", transactions.size());
        }

        logger.info("Released {} reservations for order: {}", releasedCount, orderId);
        return releasedCount;
    }
}

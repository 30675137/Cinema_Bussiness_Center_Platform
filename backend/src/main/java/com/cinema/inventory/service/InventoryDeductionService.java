/**
 * @spec P005-bom-inventory-deduction
 * InventoryDeduction Service
 *
 * Purpose: Handle inventory deduction on order fulfillment with BOM snapshot version locking
 * Author: Generated by P005 spec
 * Date: 2025-12-29
 */

package com.cinema.inventory.service;

import com.cinema.inventory.entity.*;
import com.cinema.inventory.exception.BusinessException;
import com.cinema.inventory.exception.InsufficientCurrentInventoryException;
import com.cinema.inventory.exception.InventoryErrorCode;
import com.cinema.inventory.repository.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.*;

/**
 * Inventory Deduction Service
 *
 * Handles actual inventory deduction when order is fulfilled, using BOM snapshots
 * created at reservation time to ensure version locking.
 *
 * Key Features:
 * - Uses BOM snapshot from reservation (not current formula)
 * - Atomically deducts on_hand_qty and releases reserved_qty
 * - Generates transaction logs for auditing
 * - Validates current inventory >= reserved inventory
 */
@Service
public class InventoryDeductionService {

    private static final Logger logger = LoggerFactory.getLogger(InventoryDeductionService.class);

    private final InventoryReservationRepository reservationRepository;
    private final BomSnapshotRepository bomSnapshotRepository;
    private final InventoryRepository inventoryRepository;
    private final InventoryTransactionJpaRepository transactionRepository;

    public InventoryDeductionService(
            InventoryReservationRepository reservationRepository,
            BomSnapshotRepository bomSnapshotRepository,
            InventoryRepository inventoryRepository,
            InventoryTransactionJpaRepository transactionRepository
    ) {
        this.reservationRepository = reservationRepository;
        this.bomSnapshotRepository = bomSnapshotRepository;
        this.inventoryRepository = inventoryRepository;
        this.transactionRepository = transactionRepository;
    }

    /**
     * Deduct inventory for fulfilled order
     *
     * Transaction isolation: READ_COMMITTED with pessimistic locking
     * Timeout: 30 seconds
     *
     * Steps:
     * 1. Load active reservations for order
     * 2. Load BOM snapshots for each reservation
     * 3. Calculate deduction quantities from snapshots
     * 4. Lock inventory rows (SELECT FOR UPDATE)
     * 5. Validate current_quantity >= reserved_quantity
     * 6. Deduct on_hand_qty
     * 7. Release reserved_qty
     * 8. Generate transaction logs
     * 9. Mark reservations as FULFILLED
     *
     * @param orderId Order ID
     * @param storeId Store ID
     * @return List of deducted materials with quantities
     * @throws BusinessException If reservations not found or inventory inconsistent
     */
    @Transactional(isolation = Isolation.READ_COMMITTED, rollbackFor = Exception.class, timeout = 30)
    public List<DeductedMaterial> deductInventory(UUID orderId, UUID storeId) {
        logger.info("Starting inventory deduction for order: {} at store: {}", orderId, storeId);

        // Step 1: Load active reservations
        List<InventoryReservation> reservations = reservationRepository
                .findByOrderIdAndStatus(orderId, InventoryReservation.ReservationStatus.ACTIVE);

        if (reservations.isEmpty()) {
            logger.warn("No active reservations found for order: {}", orderId);
            throw new BusinessException(
                    InventoryErrorCode.INV_NTF_001,
                    "No active reservations found for order",
                    Map.of("orderId", orderId)
            );
        }

        logger.debug("Found {} active reservations for order: {}", reservations.size(), orderId);

        // Step 2: Load BOM snapshots and calculate deduction quantities
        Map<UUID, BigDecimal> deductionQuantities = calculateDeductionQuantities(orderId, reservations);

        logger.debug("Calculated deduction quantities: {} SKUs", deductionQuantities.size());

        // Step 3: Lock inventory and validate
        List<DeductedMaterial> deductedMaterials = new ArrayList<>();
        List<InventoryTransaction> transactions = new ArrayList<>();

        for (Map.Entry<UUID, BigDecimal> entry : deductionQuantities.entrySet()) {
            UUID skuId = entry.getKey();
            BigDecimal deductQuantity = entry.getValue();

            // Lock inventory row
            Optional<Inventory> inventoryOpt = inventoryRepository
                    .findByStoreIdAndSkuIdForUpdate(storeId, skuId);

            if (inventoryOpt.isEmpty()) {
                logger.error("Inventory not found for SKU: {} at store: {}", skuId, storeId);
                throw new BusinessException(
                        InventoryErrorCode.INV_NTF_002,
                        "Inventory not found for SKU",
                        Map.of("skuId", skuId, "storeId", storeId)
                );
            }

            Inventory inventory = inventoryOpt.get();

            // Step 4: Validate current inventory >= reserved inventory
            if (inventory.getOnHandQty().compareTo(inventory.getReservedQty()) < 0) {
                logger.error("Data inconsistency: current_qty ({}) < reserved_qty ({}) for SKU: {}",
                        inventory.getOnHandQty(), inventory.getReservedQty(), skuId);
                throw new InsufficientCurrentInventoryException(
                        "SKU-" + skuId, // TODO: Get actual SKU name from database
                        inventory.getOnHandQty(),
                        inventory.getReservedQty()
                );
            }

            // Step 5: Deduct on_hand_qty
            BigDecimal previousQty = inventory.getOnHandQty();
            inventory.setOnHandQty(previousQty.subtract(deductQuantity));
            inventory.setAvailableQty(inventory.getAvailableQty().subtract(deductQuantity));

            logger.debug("Deducted {} from SKU: {}, previous: {}, new: {}",
                    deductQuantity, skuId, previousQty, inventory.getOnHandQty());

            // Step 6: Release reserved_qty
            BigDecimal previousReserved = inventory.getReservedQty();
            inventory.setReservedQty(previousReserved.subtract(deductQuantity));

            logger.debug("Released reservation {} for SKU: {}, reserved_qty: {} -> {}",
                    deductQuantity, skuId, previousReserved, inventory.getReservedQty());

            inventoryRepository.save(inventory);

            // Step 7: Generate transaction log
            InventoryTransaction transaction = new InventoryTransaction();
            transaction.setStoreId(storeId);
            transaction.setSkuId(skuId);
            transaction.setTransactionType(InventoryTransaction.TransactionType.sale_out); // Use sale_out for BOM deduction
            transaction.setQuantity(deductQuantity.negate()); // Negative for deduction
            transaction.setQuantityBefore(previousQty);
            transaction.setQuantityAfter(inventory.getOnHandQty());
            transaction.setRelatedOrderId(orderId);
            transaction.setOperatorId(UUID.randomUUID()); // TODO: Get actual operator ID from security context
            transaction.setNotes("BOM deduction for order " + orderId);

            // Get BOM snapshot ID for this SKU
            List<BomSnapshot> snapshots = bomSnapshotRepository
                    .findByOrderIdAndSkuId(orderId, skuId);
            if (!snapshots.isEmpty()) {
                transaction.setBomSnapshotId(snapshots.get(0).getId());
            }

            transactions.add(transaction);

            // Build response
            deductedMaterials.add(new DeductedMaterial(
                    skuId,
                    "SKU-" + skuId, // TODO: Get actual SKU name
                    deductQuantity,
                    "unit" // TODO: Get actual unit from SKU table
            ));
        }

        // Save transaction logs in batch
        transactionRepository.saveAll(transactions);
        logger.debug("Generated {} transaction logs", transactions.size());

        // Step 8: Mark reservations as FULFILLED
        for (InventoryReservation reservation : reservations) {
            reservation.setStatus(InventoryReservation.ReservationStatus.FULFILLED);
            reservation.setFulfilledAt(Instant.now());
        }
        reservationRepository.saveAll(reservations);

        logger.info("Successfully deducted inventory for order: {}. Deducted {} materials",
                orderId, deductedMaterials.size());

        return deductedMaterials;
    }

    /**
     * Calculate deduction quantities from BOM snapshots
     *
     * @param orderId Order ID
     * @param reservations Active reservations
     * @return Map of SKU ID -> deduction quantity
     */
    private Map<UUID, BigDecimal> calculateDeductionQuantities(
            UUID orderId,
            List<InventoryReservation> reservations
    ) {
        Map<UUID, BigDecimal> quantities = new HashMap<>();

        for (InventoryReservation reservation : reservations) {
            UUID finishedProductSkuId = reservation.getSkuId();

            // Load BOM snapshot rows for this finished product (V054 multi-row structure)
            List<BomSnapshot> snapshots = bomSnapshotRepository
                    .findByOrderIdAndSkuId(orderId, finishedProductSkuId);

            if (snapshots.isEmpty()) {
                logger.warn("No BOM snapshot found for order: {}, SKU: {}. Using direct deduction.",
                        orderId, finishedProductSkuId);
                // Fallback: directly deduct finished product
                quantities.merge(finishedProductSkuId, reservation.getReservedQuantity(), BigDecimal::add);
                continue;
            }

            // Calculate component quantities from multi-row snapshots
            BigDecimal finishedProductQty = reservation.getReservedQuantity();

            for (BomSnapshot snapshot : snapshots) {
                UUID rawMaterialSkuId = snapshot.getRawMaterialSkuId();
                BigDecimal standardQty = snapshot.getQuantity();

                // Calculate: quantity = finishedProductQty * standardQty
                // Note: V054 table doesn't have wastage_rate, so we don't apply it
                BigDecimal componentQty = finishedProductQty.multiply(standardQty);

                quantities.merge(rawMaterialSkuId, componentQty, BigDecimal::add);

                logger.debug("Deducting component from snapshot: finished={}, raw={}, qty={}",
                        finishedProductSkuId, rawMaterialSkuId, componentQty);
            }
        }

        return quantities;
    }

    /**
     * Deducted Material DTO
     */
    public static class DeductedMaterial {
        private final UUID skuId;
        private final String skuName;
        private final BigDecimal quantity;
        private final String unit;

        public DeductedMaterial(UUID skuId, String skuName, BigDecimal quantity, String unit) {
            this.skuId = skuId;
            this.skuName = skuName;
            this.quantity = quantity;
            this.unit = unit;
        }

        public UUID getSkuId() {
            return skuId;
        }

        public String getSkuName() {
            return skuName;
        }

        public BigDecimal getQuantity() {
            return quantity;
        }

        public String getUnit() {
            return unit;
        }
    }
}

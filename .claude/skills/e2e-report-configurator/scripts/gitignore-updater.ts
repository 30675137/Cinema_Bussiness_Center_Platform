/**
 * @spec T006-e2e-report-configurator
 * Gitignore file updater for report directories
 */

import { fileExists, fileContains, appendToFile } from './file-utils'

/**
 * Result of gitignore update operation
 */
export interface UpdateGitignoreResult {
  /** True if gitignore was updated (entry added) */
  updated: boolean
  /** True if entry was already present */
  alreadyPresent: boolean
  /** True if gitignore file was created */
  created: boolean
  /** The entry path that was added/checked */
  entryPath: string
}

/**
 * Updates .gitignore to exclude report directory
 *
 * Appends the report directory path to .gitignore if not already present.
 * Creates .gitignore if it doesn't exist. Adds a comment header for context.
 *
 * @param entryPath - Directory path to add to gitignore (e.g., 'reports/')
 * @param gitignorePath - Path to .gitignore file (default: '.gitignore')
 * @returns Update result
 * @throws Error if update fails
 *
 * @example
 * ```ts
 * const result = await updateGitignore('reports/', '.gitignore')
 *
 * if (result.updated) {
 *   console.log('Added reports/ to .gitignore')
 * } else if (result.alreadyPresent) {
 *   console.log('reports/ already in .gitignore')
 * }
 * ```
 */
export async function updateGitignore(
  entryPath: string,
  gitignorePath: string = '.gitignore'
): Promise<UpdateGitignoreResult> {
  // Validate entry path
  if (!entryPath || entryPath.trim() === '') {
    throw new Error('Entry path cannot be empty')
  }

  // Ensure trailing slash for directories
  const normalizedEntry = entryPath.endsWith('/') ? entryPath : `${entryPath}/`

  try {
    const gitignoreExists = await fileExists(gitignorePath)

    // If gitignore exists, check if entry already present
    if (gitignoreExists) {
      const hasEntry = await fileContains(gitignorePath, normalizedEntry)

      if (hasEntry) {
        return {
          updated: false,
          alreadyPresent: true,
          created: false,
          entryPath: normalizedEntry
        }
      }
    }

    // Prepare content to append
    const comment = '# Test reports (generated by e2e-report-configurator)'
    const content = gitignoreExists
      ? `\n${comment}\n${normalizedEntry}\n`
      : `${comment}\n${normalizedEntry}\n`

    // Append to gitignore (creates file if doesn't exist)
    await appendToFile(gitignorePath, content, {
      newlineBefore: false,
      newlineAfter: false
    })

    return {
      updated: true,
      alreadyPresent: false,
      created: !gitignoreExists,
      entryPath: normalizedEntry
    }
  } catch (error) {
    throw new Error(
      `Failed to update .gitignore: ${(error as Error).message}`
    )
  }
}

/**
 * Checks if gitignore contains specific entry
 *
 * @param entryPath - Directory path to check (e.g., 'reports/')
 * @param gitignorePath - Path to .gitignore file (default: '.gitignore')
 * @returns True if entry exists in gitignore
 *
 * @example
 * ```ts
 * const hasReports = await checkGitignoreEntry('reports/', '.gitignore')
 * ```
 */
export async function checkGitignoreEntry(
  entryPath: string,
  gitignorePath: string = '.gitignore'
): Promise<boolean> {
  // Ensure trailing slash for directories
  const normalizedEntry = entryPath.endsWith('/') ? entryPath : `${entryPath}/`

  try {
    const gitignoreExists = await fileExists(gitignorePath)

    if (!gitignoreExists) {
      return false
    }

    return await fileContains(gitignorePath, normalizedEntry)
  } catch {
    return false
  }
}

/**
 * Generates gitignore entry with comment
 *
 * @param entryPath - Directory path
 * @returns Formatted gitignore entry with comment
 *
 * @example
 * ```ts
 * const entry = generateGitignoreEntry('reports/')
 * // => "# Test reports (generated by e2e-report-configurator)\nreports/\n"
 * ```
 */
export function generateGitignoreEntry(entryPath: string): string {
  const normalizedEntry = entryPath.endsWith('/') ? entryPath : `${entryPath}/`
  const comment = '# Test reports (generated by e2e-report-configurator)'

  return `${comment}\n${normalizedEntry}\n`
}

/**
 * @spec T006-e2e-report-configurator
 * Unit tests for gitignore updater
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { updateGitignore, checkGitignoreEntry } from '@/gitignore-updater'
import * as fileUtils from '@/file-utils'

// Mock file-utils module
vi.mock('@/file-utils', () => ({
  fileExists: vi.fn(),
  fileContains: vi.fn(),
  appendToFile: vi.fn(),
  readFileContent: vi.fn()
}))

describe('gitignore-updater', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  describe('updateGitignore', () => {
    it('should append entry if gitignore exists but entry missing', async () => {
      vi.mocked(fileUtils.fileExists).mockResolvedValue(true)
      vi.mocked(fileUtils.fileContains).mockResolvedValue(false)
      vi.mocked(fileUtils.appendToFile).mockResolvedValue(undefined)

      const result = await updateGitignore('reports/', '.gitignore')

      expect(fileUtils.fileContains).toHaveBeenCalledWith('.gitignore', 'reports/')
      expect(fileUtils.appendToFile).toHaveBeenCalledWith(
        '.gitignore',
        '\n# Test reports (generated by e2e-report-configurator)\nreports/\n',
        { newlineBefore: false, newlineAfter: false }
      )
      expect(result.updated).toBe(true)
      expect(result.alreadyPresent).toBe(false)
    })

    it('should not append if entry already exists', async () => {
      vi.mocked(fileUtils.fileExists).mockResolvedValue(true)
      vi.mocked(fileUtils.fileContains).mockResolvedValue(true)

      const result = await updateGitignore('reports/', '.gitignore')

      expect(fileUtils.appendToFile).not.toHaveBeenCalled()
      expect(result.updated).toBe(false)
      expect(result.alreadyPresent).toBe(true)
    })

    it('should create gitignore if it does not exist', async () => {
      vi.mocked(fileUtils.fileExists).mockResolvedValue(false)
      vi.mocked(fileUtils.appendToFile).mockResolvedValue(undefined)

      const result = await updateGitignore('reports/', '.gitignore')

      expect(fileUtils.appendToFile).toHaveBeenCalledWith(
        '.gitignore',
        '# Test reports (generated by e2e-report-configurator)\nreports/\n',
        { newlineBefore: false, newlineAfter: false }
      )
      expect(result.updated).toBe(true)
      expect(result.created).toBe(true)
    })

    it('should handle custom entry path', async () => {
      vi.mocked(fileUtils.fileExists).mockResolvedValue(true)
      vi.mocked(fileUtils.fileContains).mockResolvedValue(false)
      vi.mocked(fileUtils.appendToFile).mockResolvedValue(undefined)

      await updateGitignore('test-reports/', '.gitignore')

      expect(fileUtils.fileContains).toHaveBeenCalledWith('.gitignore', 'test-reports/')
      expect(fileUtils.appendToFile).toHaveBeenCalledWith(
        '.gitignore',
        '\n# Test reports (generated by e2e-report-configurator)\ntest-reports/\n',
        { newlineBefore: false, newlineAfter: false }
      )
    })

    it('should handle custom gitignore path', async () => {
      vi.mocked(fileUtils.fileExists).mockResolvedValue(true)
      vi.mocked(fileUtils.fileContains).mockResolvedValue(false)
      vi.mocked(fileUtils.appendToFile).mockResolvedValue(undefined)

      await updateGitignore('reports/', 'custom/.gitignore')

      expect(fileUtils.fileExists).toHaveBeenCalledWith('custom/.gitignore')
      expect(fileUtils.appendToFile).toHaveBeenCalledWith(
        'custom/.gitignore',
        expect.any(String),
        expect.any(Object)
      )
    })

    it('should add trailing slash if missing', async () => {
      vi.mocked(fileUtils.fileExists).mockResolvedValue(true)
      vi.mocked(fileUtils.fileContains).mockResolvedValue(false)
      vi.mocked(fileUtils.appendToFile).mockResolvedValue(undefined)

      await updateGitignore('reports', '.gitignore')

      expect(fileUtils.fileContains).toHaveBeenCalledWith('.gitignore', 'reports/')
      expect(fileUtils.appendToFile).toHaveBeenCalledWith(
        '.gitignore',
        expect.stringContaining('reports/'),
        expect.any(Object)
      )
    })

    it('should handle errors during append', async () => {
      vi.mocked(fileUtils.fileExists).mockResolvedValue(true)
      vi.mocked(fileUtils.fileContains).mockResolvedValue(false)
      vi.mocked(fileUtils.appendToFile).mockRejectedValue(
        new Error('Permission denied')
      )

      await expect(updateGitignore('reports/', '.gitignore')).rejects.toThrow(
        'Permission denied'
      )
    })

    it('should include comment in appended content', async () => {
      vi.mocked(fileUtils.fileExists).mockResolvedValue(true)
      vi.mocked(fileUtils.fileContains).mockResolvedValue(false)
      vi.mocked(fileUtils.appendToFile).mockResolvedValue(undefined)

      await updateGitignore('reports/', '.gitignore')

      expect(fileUtils.appendToFile).toHaveBeenCalledWith(
        '.gitignore',
        expect.stringContaining('# Test reports (generated by e2e-report-configurator)'),
        expect.any(Object)
      )
    })
  })

  describe('checkGitignoreEntry', () => {
    it('should return true if entry exists', async () => {
      vi.mocked(fileUtils.fileExists).mockResolvedValue(true)
      vi.mocked(fileUtils.fileContains).mockResolvedValue(true)

      const exists = await checkGitignoreEntry('reports/', '.gitignore')

      expect(exists).toBe(true)
      expect(fileUtils.fileContains).toHaveBeenCalledWith('.gitignore', 'reports/')
    })

    it('should return false if entry does not exist', async () => {
      vi.mocked(fileUtils.fileExists).mockResolvedValue(true)
      vi.mocked(fileUtils.fileContains).mockResolvedValue(false)

      const exists = await checkGitignoreEntry('reports/', '.gitignore')

      expect(exists).toBe(false)
    })

    it('should return false if gitignore file does not exist', async () => {
      vi.mocked(fileUtils.fileExists).mockResolvedValue(false)

      const exists = await checkGitignoreEntry('reports/', '.gitignore')

      expect(exists).toBe(false)
      expect(fileUtils.fileContains).not.toHaveBeenCalled()
    })

    it('should add trailing slash to entry if missing', async () => {
      vi.mocked(fileUtils.fileExists).mockResolvedValue(true)
      vi.mocked(fileUtils.fileContains).mockResolvedValue(true)

      await checkGitignoreEntry('reports', '.gitignore')

      expect(fileUtils.fileContains).toHaveBeenCalledWith('.gitignore', 'reports/')
    })

    it('should handle custom gitignore path', async () => {
      vi.mocked(fileUtils.fileExists).mockResolvedValue(true)
      vi.mocked(fileUtils.fileContains).mockResolvedValue(true)

      await checkGitignoreEntry('reports/', 'custom/.gitignore')

      expect(fileUtils.fileExists).toHaveBeenCalledWith('custom/.gitignore')
      expect(fileUtils.fileContains).toHaveBeenCalledWith('custom/.gitignore', 'reports/')
    })
  })

  describe('integration scenarios', () => {
    it('should handle full update workflow', async () => {
      // Scenario: gitignore exists, entry missing, update succeeds
      vi.mocked(fileUtils.fileExists).mockResolvedValue(true)
      vi.mocked(fileUtils.fileContains).mockResolvedValue(false)
      vi.mocked(fileUtils.appendToFile).mockResolvedValue(undefined)

      const result = await updateGitignore('reports/', '.gitignore')

      expect(result).toEqual({
        updated: true,
        alreadyPresent: false,
        created: false,
        entryPath: 'reports/'
      })
    })

    it('should handle no-op scenario', async () => {
      // Scenario: gitignore exists, entry already present
      vi.mocked(fileUtils.fileExists).mockResolvedValue(true)
      vi.mocked(fileUtils.fileContains).mockResolvedValue(true)

      const result = await updateGitignore('reports/', '.gitignore')

      expect(result).toEqual({
        updated: false,
        alreadyPresent: true,
        created: false,
        entryPath: 'reports/'
      })
    })

    it('should handle fresh gitignore creation', async () => {
      // Scenario: gitignore does not exist
      vi.mocked(fileUtils.fileExists).mockResolvedValue(false)
      vi.mocked(fileUtils.appendToFile).mockResolvedValue(undefined)

      const result = await updateGitignore('reports/', '.gitignore')

      expect(result).toEqual({
        updated: true,
        alreadyPresent: false,
        created: true,
        entryPath: 'reports/'
      })
    })
  })

  describe('edge cases', () => {
    it('should handle empty entry path', async () => {
      await expect(updateGitignore('', '.gitignore')).rejects.toThrow(
        'Entry path cannot be empty'
      )
    })

    it('should handle entry paths with special characters', async () => {
      vi.mocked(fileUtils.fileExists).mockResolvedValue(true)
      vi.mocked(fileUtils.fileContains).mockResolvedValue(false)
      vi.mocked(fileUtils.appendToFile).mockResolvedValue(undefined)

      await updateGitignore('test-reports_v2/', '.gitignore')

      expect(fileUtils.appendToFile).toHaveBeenCalledWith(
        '.gitignore',
        expect.stringContaining('test-reports_v2/'),
        expect.any(Object)
      )
    })

    it('should handle nested directory paths', async () => {
      vi.mocked(fileUtils.fileExists).mockResolvedValue(true)
      vi.mocked(fileUtils.fileContains).mockResolvedValue(false)
      vi.mocked(fileUtils.appendToFile).mockResolvedValue(undefined)

      await updateGitignore('custom/reports/e2e/', '.gitignore')

      expect(fileUtils.appendToFile).toHaveBeenCalledWith(
        '.gitignore',
        expect.stringContaining('custom/reports/e2e/'),
        expect.any(Object)
      )
    })
  })
})

# 功能规格说明：环境预设命令

**功能分支**: `008-env-preset-commands`
**创建日期**: 2025-12-13
**状态**: 草稿
**用户输入**: "我想 预设几个命令 通过 比如 cc-claude 就将环境变量 设置 对应的 api key 模型 baseurl等参数"

## 澄清

### Session 2025-12-13

- Q: 命令激活机制应该如何实现（简单 alias vs 二进制工具 vs shell 函数 vs 脚本）？ → A: Shell 函数 + 配置文件（JSON/YAML）- 从配置文件读取设置，通过 shell 函数设置环境变量
- Q: 预设激活后的行为（仅设置环境变量 vs 设置并执行命令 vs 启动子 shell）？ → A: 仅设置环境变量 - 激活预设只设置环境变量，不执行任何命令
- Q: 配置文件格式（JSON vs YAML vs TOML vs INI）？ → A: JSON 格式 - 使用 JSON 文件存储预设配置（如 ~/.config/cc-presets/config.json）
- Q: 敏感凭证的加密方式（系统密钥链 vs Base64编码 vs 对称加密 vs 明文）？ → A: 明文存储 + .gitignore - 配置文件明文存储但添加到 .gitignore
- Q: 配置管理命令接口（单一命令+子命令 vs 独立命令 vs 交互式TUI vs 手动编辑）？ → A: 单一命令 + 子命令 - 使用 `cc-preset <subcommand>` 管理（如 cc-preset add/edit/delete/list）
- Q: 支持的操作系统范围？ → A: 仅支持 macOS 系统

## 用户场景与测试 *(必填)*

### 用户故事 1 - 快速环境切换 (优先级: P1)

作为一名使用多个 AI 服务提供商（Claude、OpenAI 等）的开发者，我希望能够使用简单的预设命令（如 `cc-claude` 或 `cc-openai`）快速切换不同的 API 配置，这样我就不必每次都手动设置多个环境变量。

**为什么是这个优先级**：这是核心价值主张——实现不同服务配置之间的快速切换。如果没有这个功能，用户必须手动管理环境变量，这既容易出错又耗时。

**独立测试**：可以通过运行预设命令（例如 `cc-claude`）并验证所有相关环境变量（API_KEY、MODEL、BASE_URL 等）是否在当前 shell 会话中正确设置来进行完整测试。

**验收场景**：

1. **假设** 我在一个 shell 会话中，**当** 我运行 `cc-claude` 时，**那么** 系统将 CLAUDE_API_KEY、CLAUDE_MODEL、CLAUDE_BASE_URL 环境变量设置为预设值，但不执行任何其他命令
2. **假设** 我正在使用一个配置（例如 Claude），**当** 我运行不同的预设命令（例如 `cc-openai`）时，**那么** 系统切换到新配置，并适当更新或清除之前的环境变量
3. **假设** 我想验证当前配置，**当** 我运行状态查询命令时，**那么** 系统显示当前激活的预设以及当前环境变量值（敏感数据已掩码）
4. **假设** 我已激活一个预设，**当** 我需要使用配置的服务时，**那么** 我可以直接运行相关命令（例如 `claude`），该命令将使用已设置的环境变量

---

### 用户故事 2 - 配置管理 (优先级: P2)

作为一名开发者，我希望能够通过简单的子命令创建、编辑和删除预设配置，这样我就可以为特定的开发环境定制工具，而无需手动编辑配置文件。

**为什么是这个优先级**：这使用户能够管理自己的预设配置，而无需了解配置文件格式的技术知识。对于工具的采用至关重要，但次于核心切换功能。

**独立测试**：可以通过使用 `cc-preset add` 创建新预设并提供特定参数，然后使用该预设来验证环境变量是否正确设置来独立测试。

**验收场景**：

1. **假设** 我想添加新的服务配置，**当** 我运行 `cc-preset add <名称> --api-key <密钥> --model <模型> --base-url <URL>` 时，**那么** 系统创建一个可以用 `cc-<名称>` 激活的新预设，并保存到 JSON 配置文件
2. **假设** 我有一个现有预设，**当** 我运行 `cc-preset edit <名称>` 并提供新参数时，**那么** 系统更新 JSON 配置文件中的预设配置，未来的激活将使用新值
3. **假设** 我有一个不再需要的预设，**当** 我运行 `cc-preset delete <名称>` 时，**那么** 系统从 JSON 配置文件中移除该预设，它将不再可用于激活
4. **假设** 我想查看所有可用预设，**当** 我运行 `cc-preset list` 时，**那么** 系统从 JSON 配置文件读取并显示所有已配置的预设及其关键参数（API 密钥已掩码）

---

### 用户故事 3 - 安全凭证存储 (优先级: P3)

作为一名开发者，我希望我的 API 密钥和敏感凭证能够通过文件权限保护，这样我就可以将配置文件添加到 .gitignore，避免意外提交到版本控制系统。

**为什么是这个优先级**：对于个人使用场景，文件权限保护和 .gitignore 已足够。这是最简单的实现方式，适合作为低优先级功能。

**独立测试**：可以通过创建带有敏感凭证的预设，然后验证配置文件具有适当的文件权限（仅用户可读写），且配置文件路径已添加到 .gitignore 模板中。

**验收场景**：

1. **假设** 我创建一个带有 API 密钥的新预设，**当** 我检查配置文件时，**那么** 配置文件以明文 JSON 格式存储，并且文件权限设置为仅用户可读写（chmod 600）
2. **假设** 我的配置目录中有配置文件，**当** 我检查 .gitignore 规则时，**那么** 配置文件路径已被正确排除，不会被 git 跟踪
3. **假设** 我已存储凭证，**当** 我激活预设时，**那么** 系统直接从 JSON 文件读取明文凭证并设置到环境变量中

---

### 边界情况

- 当运行预设命令但所需凭证缺失或无效时会发生什么？
- 系统如何处理不同预设之间的环境变量名称冲突？
- 如果用户尝试创建一个已存在名称的预设会发生什么？
- 如果配置文件损坏或格式错误，系统如何表现？
- 在嵌套 shell 会话中切换预设时会发生什么？
- 在具有不同参数集的预设之间切换时，环境变量如何清理？
- 当用户运行 `cc-preset add` 但缺少必需参数时会发生什么？
- 如果 JSON 配置文件不存在或无法访问，系统如何处理？

## 需求 *(必填)*

### 功能需求

- **FR-001**: 系统必须提供基于 shell 函数的命令接口用于激活预设配置（例如 `cc-claude`、`cc-openai`），函数从 JSON 配置文件读取设置并设置环境变量
- **FR-002**: 系统必须能够从单个预设激活命令设置多个环境变量
- **FR-003**: 系统必须至少支持为每个预设配置：API 密钥、模型名称和基础 URL
- **FR-004**: 系统必须提供 `cc-preset add` 子命令用于创建新预设，并将其保存到 JSON 配置文件
- **FR-005**: 系统必须提供 `cc-preset edit` 子命令用于编辑现有预设，并更新 JSON 配置文件
- **FR-006**: 系统必须提供 `cc-preset delete` 子命令用于删除预设，并从 JSON 配置文件中移除
- **FR-007**: 系统必须提供 `cc-preset list` 子命令用于列出所有可用预设及其配置（从 JSON 配置文件读取）
- **FR-008**: 系统必须提供 `cc-preset status` 或类似子命令显示当前激活的预设和环境变量值（敏感数据已掩码）
- **FR-009**: 系统必须在 shell 会话之间持久化预设配置（通过 JSON 配置文件存储）
- **FR-010**: 系统必须通过文件权限（chmod 600）和 .gitignore 保护配置文件，防止意外暴露 API 密钥和敏感凭证
- **FR-011**: 系统必须在创建或编辑预设时验证所需参数
- **FR-012**: 系统必须通过在覆盖前提示用户确认来处理预设名称冲突
- **FR-013**: 系统必须在预设激活失败时提供清晰的错误消息
- **FR-014**: 系统必须使用 shell 函数机制以便预设命令能够直接修改当前 shell 环境（而非子进程）
- **FR-015**: 系统必须允许为每个预设配置自定义环境变量名称
- **FR-016**: 系统必须提供 `cc-preset --help` 显示所有可用子命令和使用说明

### 核心实体

- **预设（Preset）**: 特定服务或上下文的环境变量配置的命名集合。包括预设名称（例如 "claude"、"openai"）、环境变量映射（键值对）、元数据（创建日期、最后修改时间）以及安全设置（哪些值应该加密）。

- **环境变量（Environment Variable）**: 激活预设时将在 shell 环境中设置的键值对。包括变量名称、变量值、敏感标志（值是否应在显示时掩码/在存储时加密）以及可选的验证规则。

- **配置存储（Configuration Store）**: 以 JSON 格式存储的所有预设定义文件（如 ~/.config/cc-presets/config.json）。包含多个预设、用户首选项（默认预设、显示设置）以及安全设置（加密方法、凭证存储集成）。

## 成功标准 *(必填)*

### 可衡量成果

- **SC-001**: 用户可以使用单个命令在 5 秒内切换不同的服务配置
- **SC-002**: 预设激活成功率高于 95%（失败仅由于凭证缺失或配置错误）
- **SC-003**: 用户可以在 60 秒内通过命令接口创建新预设
- **SC-004**: 所有配置文件具有适当的文件权限（仅用户可读写），并且配置目录已添加到 .gitignore 模板中
- **SC-005**: 用户可以在 3 秒内列出所有可用预设并查看当前配置
- **SC-006**: 90% 的用户在首次尝试时成功激活预设而无需查阅文档
- **SC-007**: 配置更改（创建、编辑、删除）在所有后续 shell 会话中持久存在

## 假设

- 用户具有基本的命令行经验并理解环境变量
- 用户在 macOS 系统上的 shell 环境（bash 或 zsh）中工作
- 每个预设适用于单个用户的机器（不是为多用户系统范围配置设计的）
- API 提供商使用环境变量作为配置的主要方法
- 用户具有适当的文件系统权限以在其主目录中存储配置文件
- 活跃用户每天将多次调用该工具（证明速度优化是合理的）
- 用户可能经常使用 3-10 种不同的服务配置
- macOS 默认 shell 为 zsh（macOS Catalina 及更高版本）或 bash（较旧版本）

## 依赖项

- 访问文件系统以在用户主目录中存储配置（如 ~/.config/cc-presets/）
- Shell 集成能力（能够修改当前 shell 中的环境变量，而不仅仅是子进程）
- JSON 解析工具（macOS 自带 python3 可用于 JSON 解析，或使用 jq）
- 用户的 shell 配置文件访问权限，用于安装 shell 函数（~/.zshrc 或 ~/.bash_profile）

## 约束条件

- 仅支持 macOS 操作系统（不考虑 Linux 或 Windows 兼容性）
- 必须在 macOS 的 bash 和 zsh shell 环境中工作
- 配置文件必须存储在用户可访问的位置（不需要 root/管理员权限）
- 预设激活必须在 5 秒内完成，以避免中断开发者工作流程
- 不得干扰托管预设之外的手动设置的环境变量
- 解决方案不应要求复杂的安装程序或外部依赖项（可使用 macOS 自带工具）

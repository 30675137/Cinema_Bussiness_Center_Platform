# 功能规格说明: H5小程序后端API集成

**功能分支**: `O007-h5-api-integration`
**创建日期**: 2026-01-03
**状态**: 草稿
**输入**: 将miniapp-ordering 改造为可以调用后端api的H5小程序

## Clarifications

### Session 2026-01-03

- Q: UI设计还原度中原型代码的位置和组件化策略 → A: 必须100%还原 miniapp-ordering/ 中原型的UI设计(布局/配色/字体/间距/圆角/阴影/空间),不得随意修改视觉风格与布局,但是可以考虑将其组件化
- Q: 实施位置和原型代码处理方式 → A: 在 miniapp-ordering/ 文件夹中直接实现 Taro 重构,不创建其他同级文件夹,原型代码作为UI设计参考保持在同一文件夹中

## 用户场景与测试 *(必填)*

### 用户故事 1 - 从后端加载真实商品数据 (优先级: P1)

作为小程序用户,我希望在商品列表页面看到从后端API加载的真实商品数据(而非前端Mock数据),包括商品名称、价格、图片、分类等信息,以便选购真实的影院商品。

**优先级说明**: 这是从原型到生产环境的核心转换,没有真实数据就无法实际使用。这是最基础的MVP功能,所有其他功能都依赖于此。

**独立测试**: 用户打开小程序 → 查看商品列表页 → 验证显示的商品数据来自后端API(通过网络面板验证API调用) → 商品信息与后台配置一致。

**验收场景**:

1. **假设** 用户首次打开小程序商品列表页,**当** 页面加载,**则** 发起GET请求到 `/api/channel-products/client/list` 并显示返回的商品数据
2. **假设** 后端返回10个商品,**当** 数据加载完成,**则** 页面渲染10个商品卡片,每个卡片显示正确的商品名称、价格、主图
3. **假设** 后端API返回错误(如500),**当** 请求失败,**则** 显示友好的错误提示"加载失败,请稍后重试"并提供重新加载按钮
4. **假设** 网络连接断开,**当** 用户尝试加载商品,**则** 显示"网络连接失败"提示
5. **假设** 后端返回空数组,**当** 数据加载完成,**则** 显示空状态页面"暂无商品"

---

### 用户故事 2 - 按分类筛选商品 (优先级: P1)

作为小程序用户,我希望通过点击分类标签(咖啡/饮料/小食等)筛选商品,查看特定分类下的商品列表,以便快速找到我想要的商品类型。

**优先级说明**: 分类筛选是用户快速查找商品的核心交互,与商品展示同等重要,是P1级别的基础功能。

**独立测试**: 用户在商品列表页点击"咖啡"分类标签 → 列表仅显示咖啡类商品 → 再点击"全部"标签恢复所有商品。

**验收场景**:

1. **假设** 用户在商品列表页,**当** 点击"咖啡"分类标签,**则** 发起GET请求 `/api/channel-products/client/list?category=COFFEE` 并仅显示咖啡类商品
2. **假设** 用户选择了"饮料"分类,**当** 点击"全部"标签,**则** 发起不带category参数的请求,显示所有商品
3. **假设** 某个分类下没有商品,**当** 用户选择该分类,**则** 显示"该分类暂无商品"提示
4. **假设** 用户在筛选状态下,**当** 下拉刷新页面,**则** 保持当前分类的筛选状态重新加载数据

---

### 用户故事 3 - 查看商品详情与规格选择 (优先级: P1)

作为小程序用户,我希望点击商品卡片后查看详细信息(详情图、规格选项),并通过弹窗选择规格(尺寸/温度/甜度等),以便根据个人喜好定制商品。

**优先级说明**: 规格选择是订单创建的必要步骤,用户必须能够选择规格才能加入购物车,是核心订单流程的一部分。

**独立测试**: 用户点击某个商品 → 弹出规格选择弹窗 → 选择尺寸/温度/甜度 → 查看价格实时更新 → 点击"加入购物车"。

**验收场景**:

1. **假设** 用户点击某个商品卡片,**当** 弹窗打开,**则** 发起GET请求 `/api/channel-products/client/{id}` 获取商品详情和可用规格选项
2. **假设** 商品有3种规格类型(SIZE/TEMPERATURE/SWEETNESS),**当** 详情页加载,**则** 显示3个规格选择器,每个显示对应的选项列表
3. **假设** 用户选择"大杯"尺寸,**当** 选择完成,**则** 价格根据规格加价规则更新(如大杯+5元)
4. **假设** 用户未选择必选规格,**当** 点击"加入购物车",**则** 提示"请选择[规格名称]"并禁止添加
5. **假设** 某商品无规格选项,**当** 点击商品,**则** 直接显示"加入购物车"按钮,无需规格选择步骤

---

### 用户故事 4 - 购物车管理 (优先级: P2)

作为小程序用户,我希望在购物车中查看已选择的商品及其规格、数量、小计金额,并能修改数量或删除商品,以便在下单前调整订单内容。

**优先级说明**: 购物车是订单确认前的缓冲区,虽然重要但可以在商品展示后实现。用户可以直接购买单个商品而不依赖购物车。

**独立测试**: 用户添加3个商品到购物车 → 打开购物车抽屉 → 修改某个商品数量 → 删除某个商品 → 验证总价更新正确。

**验收场景**:

1. **假设** 用户选择规格后点击"加入购物车",**当** 操作完成,**则** 购物车徽章数量+1,商品添加到本地存储(Taro.setStorageSync)
2. **假设** 购物车有5个商品,**当** 用户打开购物车抽屉,**则** 显示5个商品项,每项显示商品名、规格、单价、数量、小计
3. **假设** 用户点击商品数量"-"按钮,**当** 数量减到0,**则** 商品从购物车移除,总价重新计算
4. **假设** 用户点击"清空购物车",**当** 确认操作,**则** 所有商品清除,购物车徽章归零
5. **假设** 购物车为空,**当** 用户打开购物车抽屉,**则** 显示"购物车是空的"空状态提示

---

### 用户故事 5 - 创建订单并提交 (优先级: P2)

作为小程序用户,我希望在购物车确认商品无误后提交订单,系统调用后端API创建订单记录并返回订单号,以便进入支付流程。

**优先级说明**: 订单创建是完整交易流程的核心步骤,但可以在购物车功能完成后实现。用户需要先能够管理购物车才能提交订单。

**独立测试**: 用户在购物车点击"提交订单" → 验证发起POST请求到 `/api/orders/create` → 接收订单号 → 跳转到订单详情页。

**验收场景**:

1. **假设** 用户购物车有3个商品,**当** 点击"提交订单",**则** 发起POST请求 `/api/orders/create` 包含商品列表、规格、数量、总价
2. **假设** 后端创建订单成功,**当** 响应返回,**则** 显示"订单创建成功"提示,清空购物车,跳转到订单详情页
3. **假设** 后端返回库存不足错误,**当** 请求失败,**则** 显示具体错误提示"[商品名]库存不足",购物车保持原状
4. **假设** 用户提交订单时,**当** 某个商品已下架,**则** 提示"[商品名]已下架,请移除后重试"
5. **假设** 订单提交中(loading状态),**当** 用户再次点击按钮,**则** 按钮禁用,防止重复提交

---

### 用户故事 6 - 查看订单列表与详情 (优先级: P3)

作为小程序用户,我希望在"我的订单"页面查看历史订单列表,点击订单查看详情(商品明细/订单状态/创建时间),以便追踪订单进度。

**优先级说明**: 订单历史查询是辅助功能,不影响核心下单流程。用户可以先完成下单,后期再查看历史订单。

**独立测试**: 用户打开"我的订单"页 → 查看订单列表(按时间倒序) → 点击某个订单 → 查看订单详情页面。

**验收场景**:

1. **假设** 用户打开"我的订单"页,**当** 页面加载,**则** 发起GET请求 `/api/orders/list` 并显示订单列表(按创建时间倒序)
2. **假设** 订单列表有10个订单,**当** 数据加载完成,**则** 显示10个订单卡片,每个显示订单号、状态、商品数量、总价、创建时间
3. **假设** 用户点击某个订单,**当** 跳转到详情页,**则** 发起GET请求 `/api/orders/{orderId}` 并显示订单详细信息(商品明细/规格/单价/数量/订单状态)
4. **假设** 用户下拉刷新订单列表,**当** 刷新完成,**则** 更新订单状态(如"待支付"变为"已完成")
5. **假设** 用户没有任何订单,**当** 打开订单页,**则** 显示空状态"暂无订单记录"

---

### 边界情况

- **网络异常场景**:
  - 当API请求超时(>10秒)时,显示"请求超时,请检查网络"提示
  - 当设备完全离线时,所有需要网络的操作显示"无网络连接"提示,购物车数据保留在本地

- **数据一致性场景**:
  - 当用户在购物车页面时,某个商品被后台下架,提交订单时返回错误并提示用户移除该商品
  - 当商品价格在用户浏览期间被修改,订单创建时以当前最新价格为准,并提示用户"价格已更新"

- **并发操作场景**:
  - 当用户快速连续点击"加入购物车"按钮,通过防抖机制(300ms)防止重复添加
  - 当用户在多个设备同时登录,购物车数据以最后提交的设备为准(覆盖模式)

- **边界数据场景**:
  - 当商品图片URL无效或加载失败,显示默认占位图
  - 当商品名称超长(>50字符),使用省略号截断显示
  - 当购物车商品数量超过99,显示"99+"徽章

- **特殊规格场景**:
  - 当某个规格选项库存为0,该选项显示为灰色禁用状态并标注"已售罄"
  - 当商品的某个规格组合无货(如"大杯+热饮"),选择时实时提示"该组合暂不可选"

## 需求说明 *(必填)*

### 功能需求

- **FR-001**: 系统必须通过调用 `/api/channel-products/client/list` 获取商品列表,返回包含商品ID、名称、价格、主图URL、分类、状态等字段
- **FR-002**: 系统必须支持按商品分类筛选,调用 `/api/channel-products/client/list?category={CATEGORY}` 获取特定分类商品(COFFEE/BEVERAGE/SNACK/ALCOHOL/MEAL/OTHER)
- **FR-003**: 系统必须在用户点击商品时调用 `/api/channel-products/client/{id}` 获取商品详情,包括详情图、规格配置(SIZE/TEMPERATURE/SWEETNESS/TOPPING/SPICINESS等)
- **FR-004**: 系统必须支持规格选择器UI,展示商品的可用规格选项,并根据规格选择实时计算价格(基础价格+规格加价)
- **FR-005**: 系统必须将用户选择的商品及规格保存到本地购物车存储(`Taro.setStorageSync('cart', cartData)`),支持增删改查操作
- **FR-006**: 系统必须在购物车页面计算总价,公式为: `总价 = Σ(商品单价 × 数量)`
- **FR-007**: 系统必须在用户点击"提交订单"时调用 `/api/orders/create`,请求体包含: `{ items: [{ channelProductId, specSelections, quantity, price }], totalAmount }`
- **FR-008**: 系统必须在订单创建成功后清空购物车本地存储,并跳转到订单详情页显示订单号
- **FR-009**: 系统必须通过调用 `/api/orders/list` 获取用户历史订单列表,支持分页查询
- **FR-010**: 系统必须在订单详情页调用 `/api/orders/{orderId}` 获取订单完整信息,包括商品明细、规格、状态、创建时间
- **FR-011**: 系统必须在网络请求失败时显示统一的错误提示,根据HTTP状态码区分错误类型(400参数错误/404资源不存在/500服务器错误)
- **FR-012**: 系统必须支持下拉刷新功能(商品列表页/订单列表页),使用 `Taro.stopPullDownRefresh()` 结束刷新动画
- **FR-013**: 系统必须在商品图片加载失败时显示默认占位图(存储在 `src/assets/images/placeholder.png`)
- **FR-014**: 系统必须对用户快速点击操作实施防抖保护(300ms间隔),防止重复提交请求
- **FR-015**: 系统必须在购物车为空时禁用"提交订单"按钮并显示灰色样式

### 关键实体

- **渠道商品 (ChannelProduct)**: 渠道商品实体,关键属性包括: `id`(商品ID), `name`(商品名称), `basePrice`(基础价格), `category`(商品分类枚举), `mainImageUrl`(主图), `detailImages`(详情图数组), `status`(上架状态), `specConfigs`(规格配置数组)

- **规格配置 (SpecConfig)**: 规格配置实体,关键属性包括: `type`(规格类型: SIZE/TEMPERATURE/SWEETNESS等), `options`(选项数组), 每个选项包含 `name`(选项名称), `priceModifier`(价格调整), `isAvailable`(是否可用)

- **购物车商品项 (CartItem)**: 购物车商品项,关键属性包括: `channelProductId`(商品ID), `productName`(商品名称), `specSelections`(用户选择的规格组合,格式: `{SIZE: '大杯', TEMPERATURE: '热'})`), `quantity`(数量), `unitPrice`(单价), `subtotal`(小计金额)

- **订单 (Order)**: 订单实体,关键属性包括: `orderId`(订单号), `items`(订单项数组,每项包含商品ID/规格/数量/价格), `totalAmount`(订单总金额), `status`(订单状态: PENDING/PAID/COMPLETED/CANCELLED), `createdAt`(创建时间), `userId`(用户ID)

## 成功标准 *(必填)*

### 可衡量的成果

- **SC-001**: 用户从打开商品列表到看到商品数据的时间不超过2秒(P95延迟)
- **SC-002**: 商品列表页的下拉刷新操作能在1秒内完成数据更新并停止加载动画
- **SC-003**: 用户从选择规格到成功加入购物车的操作不超过5次点击
- **SC-004**: 购物车总价计算的准确率达到100%(无浮点数精度错误)
- **SC-005**: 订单提交成功率达到95%以上(排除网络故障和用户主动取消),失败订单能明确提示错误原因
- **SC-006**: 所有API请求的重试机制能在3次重试后仍失败时显示明确的错误提示
- **SC-007**: 购物车数据在小程序关闭后重新打开时能够保留(本地存储持久化)
- **SC-008**: 商品分类筛选功能的响应时间不超过500毫秒
- **SC-009**: 用户在订单列表页能够快速定位最近的订单(列表按创建时间倒序排列)

## 假设前提

- **后端API已就绪**: 假设后端已完成 O005-channel-product-config 和 O006-miniapp-channel-order 的实现,所有需要的API端点(`/api/channel-products/client/*`, `/api/orders/*`)均可正常调用

- **微信小程序环境**: 假设应用运行在微信小程序环境或H5环境(Taro框架支持),可以使用 `Taro.request()`, `Taro.setStorageSync()` 等API

- **商品数据格式**: 假设后端返回的商品数据格式符合前端预期,包含所有必需字段(id/name/basePrice/category/mainImageUrl等)

- **规格定价模型**: 假设规格选项的价格调整(priceModifier)为增量值(如大杯+5元),最终价格 = 基础价格 + Σ(选中规格的priceModifier)

- **购物车存储策略**: 假设购物车数据仅存储在客户端本地,不同步到服务器,订单创建时才将购物车内容发送到后端

- **网络环境**: 假设用户使用移动网络或Wi-Fi,网络延迟在100-500ms之间,API超时时间设置为10秒

- **图片资源**: 假设后端返回的图片URL为HTTPS协议,支持微信小程序的域名白名单,图片大小不超过2MB

- **订单状态流转**: 假设订单状态由后端管理,小程序仅展示状态,不涉及支付流程的实现(支付功能由其他spec负责)

- **设备兼容性**: 假设应用运行在iOS 12+和Android 8.0+设备上,屏幕宽度在320px-750px之间(使用rpx单位适配)

## 依赖关系

- **O005-channel-product-config**: 依赖渠道商品配置功能,提供商品主数据和规格配置的API
- **O006-miniapp-channel-order**: 依赖小程序订单功能的后端实现,提供订单创建和查询的API

## 不包含的范围

- **身份认证与登录**: 本规格不包含微信登录、token管理、用户认证等功能,由其他spec负责(U003-wechat-miniapp-login)
- **支付功能**: 本规格不包含支付流程(微信支付/支付宝等),订单创建后的支付由其他spec负责
- **优惠券/积分系统**: 不包含优惠券选择、积分兑换等营销功能,订单金额为商品原价总和
- **AI推荐功能**: 原型中的Gemini AI推荐功能暂不实现,待后续通过后端推荐算法实现
- **影厅选择**: 原型中的影厅选择功能不适用于本场景,移除此功能
- **订单状态流转**: 订单状态(待支付→已支付→已完成)的后端逻辑由其他spec负责,本spec仅展示状态
- **用户个人信息管理**: 不包含用户资料编辑、收货地址管理等功能
- **商品收藏/分享**: 不包含商品收藏夹、分享到好友/朋友圈等社交功能
- **订单评价**: 不包含订单完成后的评价/评分功能
- **库存实时提示**: 不实时展示库存数量,仅在下单时由后端校验库存是否充足

## 技术约束

- **框架版本**: 必须使用 Taro 4.1.9 + React 18.3.1 + TypeScript 5.4.0,与项目现有 hall-reserve-taro 技术栈保持一致
- **状态管理**: 必须使用 Zustand 进行客户端状态管理(购物车状态/用户登录状态),TanStack Query 进行服务器状态管理(API数据缓存)
- **样式单位**: 必须使用 rpx 单位(750设计稿基准),确保多设备适配
- **构建工具**: 必须使用 Taro CLI 进行构建,支持微信小程序和H5双端编译
- **API请求库**: 必须使用 Taro.request 封装统一的HTTP请求方法,不使用axios等第三方库
- **存储API**: 必须使用 Taro.setStorageSync/getStorageSync 进行本地存储,不使用localStorage
- **开发环境**: 开发服务器端口为10086(Taro H5默认),后端API代理到 http://localhost:8080

## UI/UX约束

- **UI设计还原度**: 必须100%还原 miniapp-ordering/ 中原型的UI设计(布局/配色/字体/间距/圆角/阴影/空间),不得随意修改视觉风格与布局,但是可以考虑将其组件化
- **样式变量提取**: 必须从原型CSS文件中精确提取所有样式变量(颜色/字号/间距等),转换为SCSS变量存储在 `src/styles/variables.scss`
- **图标库**: 必须使用 lucide-react 图标库(Taro兼容),确保图标样式与原型一致
- **交互动效**: 简化原型中的复杂动画(弹簧动画/缓动效果),仅保留基础的页面切换过渡(淡入淡出),优先保证性能流畅
- **响应式设计**: 必须适配iPhone 6/7/8(375px)到iPhone 14 Pro Max(428px)的屏幕宽度,使用rpx单位确保等比缩放
- **加载状态**: 所有异步操作(数据加载/订单提交)必须显示loading指示器,避免用户误以为操作无响应
- **空状态设计**: 所有列表页(商品列表/订单列表/购物车)必须提供空状态插图和引导文案,避免空白页面
- **错误提示**: 所有错误信息必须使用 Taro.showToast 或 Taro.showModal 显示,文案清晰且提供解决建议

## 备注说明

- **原型代码处理**: 现有 miniapp-ordering/ 目录下的 React web app 原型代码作为UI设计参考,在同一文件夹中进行 Taro 重构时保持UI一致性

- **实施位置**: 在 `miniapp-ordering/` 文件夹中直接实现 Taro 重构,不创建其他同级文件夹,不修改 `hall-reserve-taro/` 旧项目

- **API契约参考**: 后端API的请求/响应格式应参考 `specs/O005-channel-product-config/contracts/api.yaml` 和 `specs/O006-miniapp-channel-order/contracts/api.yaml`

- **错误编号规范**: 后端返回的错误码应遵循模块前缀规则(如 `ORD_VAL_001`),前端根据error字段而非message处理错误

- **测试策略**: 建议先使用Mock数据进行UI开发和调试,待UI完全还原后再切换到真实后端API

- **分支策略**: 本spec对应分支 `O007-h5-api-integration`,完成后合并到主分支 `001-ui-implementation`

- **性能优化**: 商品列表应实现虚拟滚动或分页加载,避免一次性渲染大量商品导致性能问题

- **安全注意**: Token不得明文存储在代码中,必须通过环境变量或安全存储方案管理,生产环境使用HTTPS协议

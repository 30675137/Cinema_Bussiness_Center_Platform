# 功能规格说明书：E2E 测试数据规划器

**功能分支**: `T004-e2e-testdata-planner`
**创建日期**: 2025-12-30
**状态**: 草稿
**输入描述**: "E2E测试数据规划器 - 数据契约与供给策略的源头"

<!--
  规格编号格式说明 (Spec ID Format):
  X### 其中:
  - X: 模块字母 (S=门店/影厅, P=商品/库存, B=品牌/分类, A=活动/场景包, U=用户/预订, T=工具/基础设施, F=前端基础)
  - ###: 模块内递增的三位数字 (001-999)

  示例: S001-store-crud, P012-inventory-management, A005-scenario-package-tabs
-->

## 用户场景与测试 *(必填)*

<!--
  重要说明：用户故事应按重要性排序并设置优先级。
  每个用户故事/旅程必须是可独立测试的 - 意味着如果你只实现其中一个，
  仍然能得到一个可交付价值的最小可行产品（MVP）。

  为每个故事分配优先级（P1, P2, P3 等），P1 是最关键的。
  将每个故事视为独立的功能切片，可以：
  - 独立开发
  - 独立测试
  - 独立部署
  - 独立向用户演示
-->

### 用户故事 1 - 定义测试数据蓝图 (优先级: P1)

作为测试开发者，我希望能够定义带有唯一 testdata_ref 标识符的测试数据蓝图（例如 TD-ORDER-001、TD-USER-ADMIN），以便测试场景可以引用标准化的数据契约，而不耦合到特定的供给实现。

**优先级理由**: 这是整个系统的基础。没有数据蓝图，我们无法建立契约或生成数据。通过创建测试数据定义的单一真实来源，这能立即交付价值。

**独立测试**: 可以通过创建蓝图文件（例如 `testdata/blueprints/order.blueprint.yaml`）、验证其模式、并确认规划器能够加载它来完全测试。即使在实现之前，也能通过启用数据契约文档化来交付价值。

**验收场景**:

1. **假设** 我在 `testdata/blueprints/order.blueprint.yaml` 有一个蓝图文件，**当** 我定义一个包含模式和依赖的 testdata_ref `TD-ORDER-001` 时，**那么** 规划器验证蓝图结构并注册数据契约
2. **假设** 我在测试场景中引用 `testdata_ref: TD-USER-ADMIN`，**当** 规划器加载蓝图时，**那么** 它解析蓝图定义并验证所有必填字段已指定
3. **假设** 蓝图依赖其他 testdata_refs（例如 TD-ORDER-001 依赖 TD-USER-001），**当** 规划器验证蓝图时，**那么** 它检测并报告循环依赖或缺失依赖

---

### 用户故事 2 - 选择数据供给策略 (优先级: P1)

作为测试开发者，我希望能够为每个 testdata_ref 配置数据供给策略（seed/api/db-script），以便根据环境约束和测试需求选择最合适的测试数据供给方法。

**优先级理由**: 这对于使系统实用化至关重要。不同的环境（CI、预发、类生产环境）需要不同的数据供给方法。这使系统能够在真实场景中工作。

**独立测试**: 可以通过定义带有策略元数据的蓝图（`strategy: seed`、`strategy: api`、`strategy: db-script`），并验证规划器根据配置选择正确的提供者来完全测试。通过启用特定环境的数据供给来交付价值。

**验收场景**:

1. **假设** 蓝图配置为 `strategy: seed` 和 `seedFilePath: "testdata/seeds/users.json"`，**当** 规划器生成供给计划时，**那么** 它输出一个从种子文件加载数据的 fixture
2. **假设** 蓝图配置为 `strategy: api` 和 `apiEndpoint: "/api/test/users"`，**当** 规划器生成供给计划时，**那么** 它创建一个带认证调用 API 端点的 fixture
3. **假设** 蓝图配置为 `strategy: db-script` 和 `dbScriptPath: "testdata/scripts/seed-orders.sql"`，**当** 规划器生成供给计划时，**那么** 它创建一个通过 Supabase 客户端执行 SQL 脚本的 fixture

---

### 用户故事 3 - 生成生命周期计划 (优先级: P1)

作为测试开发者，我希望规划器能够生成测试数据的生命周期计划（setup/teardown），以便测试可以自动供给和清理数据，无需手动编写脚本。

**优先级理由**: 这对于测试可靠性和隔离性至关重要。没有适当的 setup/teardown，测试会变得不稳定并污染环境。这是 MVP 在生产使用中的关键要素。

**独立测试**: 可以通过为蓝图生成生命周期计划、验证 setup 和 teardown 代码、并在 Playwright fixture 中运行它来完全测试。通过自动化测试数据管理来交付价值。

**验收场景**:

1. **假设** 蓝图 `TD-ORDER-001` 依赖 `TD-USER-001` 和 `TD-STORE-001`，**当** 规划器生成生命周期计划时，**那么** 它创建一个先供给依赖、再供给目标实体的 setup 序列
2. **假设** 生命周期计划配置为 `teardown: true`，**当** 测试完成时，**那么** 规划器生成按反向依赖顺序删除测试数据的 teardown 代码
3. **假设** 蓝图配置为 `scope: test`（测试级 fixture），**当** 规划器生成 Playwright fixtures 时，**那么** 它创建一个在每个测试前运行 setup、测试后运行 teardown 的 test fixture

---

### 用户故事 4 - 验证数据契约 (优先级: P2)

作为测试开发者，我希望规划器能够验证测试场景只引用有效的 testdata_refs 并且所有必需的依赖都已满足，以便在测试执行前捕获契约违规。

**优先级理由**: 这改善了开发者体验并能及早发现错误。虽然重要，但对 MVP 功能并非关键 - 没有验证测试仍能运行，只是错误消息会更糟糕。

**独立测试**: 可以通过创建一个引用无效 testdata_ref 的场景（例如 `testdata_ref: TD-NONEXISTENT`）、运行验证、并确认规划器报告错误并提供有用建议来完全测试。通过防止运行时失败来交付价值。

**验收场景**:

1. **假设** 测试场景引用不存在的 `testdata_ref: TD-ORDER-999`，**当** 我运行验证时，**那么** 规划器报告错误并显示可用的 testdata_refs
2. **假设** 蓝图必需依赖 `TD-USER-001` 但场景未包含它，**当** 我运行验证时，**那么** 规划器报告缺失依赖
3. **假设** 蓝图要求 `env_profile: production` 但场景指定 `env_profile: staging`，**当** 我运行验证时，**那么** 规划器报告环境不匹配

---

### 用户故事 5 - 生成 Fixture 代码 (优先级: P2)

作为测试开发者，我希望规划器能够从生命周期计划生成 Playwright fixture 代码，以便我可以将测试数据供给集成到测试框架中，无需手动实现。

**优先级理由**: 这节省大量开发时间并确保测试间的一致性。但开发者可以在需要时手动编写 fixtures，所以不是 MVP 关键要素。

**独立测试**: 可以通过为蓝图生成 fixture 代码、在 Playwright 测试中导入它、并验证 fixture 提供预期数据来完全测试。通过自动化样板代码来交付价值。

**验收场景**:

1. **假设** 有一个 `TD-ORDER-001` 的生命周期计划，**当** 我生成 fixture 代码时，**那么** 它输出一个包含正确导入、类型定义和 fixture 实现的 TypeScript 文件
2. **假设** 蓝图配置为 `strategy: api`，**当** 我生成 fixture 代码时，**那么** fixture 包含认证头和错误处理
3. **假设** 多个蓝图有不同的作用域（test/worker/global），**当** 我生成 fixtures 时，**那么** 每个 fixture 在 Playwright 的 fixture 系统中正确设置作用域

---

### 用户故事 6 - 诊断供给问题 (优先级: P3)

作为测试开发者，我希望有诊断工具帮助我排查数据供给失败（例如 API 超时、缺失种子文件、权限错误），以便快速解决问题而无需深度调试。

**优先级理由**: 这改善了可维护性但对初始功能不是必需的。开发者可以手动调试，所以这是一个生活质量改进。

**独立测试**: 可以通过模拟供给失败（例如无法访问的 API 端点）、运行诊断、并验证规划器提供可操作的错误消息来完全测试。通过减少调试时间来交付价值。

**验收场景**:

1. **假设** 蓝图配置为 `strategy: api` 并且端点无法访问，**当** 我运行诊断时，**那么** 规划器报告网络错误并提供重试建议
2. **假设** 蓝图配置为 `strategy: seed` 并且种子文件缺失，**当** 我运行诊断时，**那么** 规划器报告缺失的文件路径并建议创建它
3. **假设** 蓝图配置为 `strategy: db-script` 但数据库权限不足，**当** 我运行诊断时，**那么** 规划器报告权限错误并显示所需角色

---

### 边界情况

- **循环依赖**: 当 TD-ORDER-001 依赖 TD-USER-001，而 TD-USER-001 又依赖 TD-ORDER-001 时会发生什么？规划器必须检测并报告错误。
- **环境不匹配**: 当蓝图要求 `env_profile: production` 但测试使用 `env_profile: staging` 运行时，系统如何处理？规划器必须验证并报告不匹配。
- **并发数据冲突**: 当多个并行测试请求相同的唯一 testdata_ref（例如 TD-USER-ADMIN）时会发生什么？规划器必须支持共享 fixtures 或测试隔离策略。
- **缺失种子文件**: 当 `strategy: seed` 引用不存在的文件时，系统如何处理？规划器必须尽早失败并提供清晰的错误消息。
- **API 认证失败**: 当 `strategy: api` 因令牌过期或凭据无效而失败时会发生什么？规划器必须报告认证错误并提供补救步骤。
- **数据库脚本错误**: 系统如何处理 db-scripts 中的 SQL 语法错误或约束违规？规划器必须显示带上下文的数据库错误。
- **大数据量**: 当种子文件超过内存限制（例如 10,000+ 条记录）时会发生什么？规划器必须支持流式或分块加载。
- **数据版本冲突**: 当种子文件格式改变但测试仍引用旧版本时，系统如何处理？规划器必须支持版本控制或模式迁移。
- **Teardown 失败**: 当 teardown 失败（例如外键约束阻止删除）时会发生什么？规划器必须记录失败并可选择使用级联选项重试。
- **跨环境数据泄漏**: 系统如何防止意外在 staging 测试中使用生产数据？规划器必须强制环境边界。

## 需求 *(必填)*

### 功能需求

- **FR-001**: 系统必须从 `testdata/blueprints/` 目录加载并验证 YAML 格式的测试数据蓝图文件
- **FR-002**: 系统必须支持三种数据供给策略：`seed`（静态文件）、`api`（通过 REST 动态创建）、`db-script`（直接 SQL 执行）
- **FR-003**: 系统必须从生命周期计划生成 Playwright fixtures（test/worker/global 作用域）
- **FR-004**: 系统必须验证测试场景中的所有 testdata_ref 引用都能解析到有效蓝图
- **FR-005**: 系统必须检测并报告 testdata_refs 之间的循环依赖
- **FR-006**: 系统必须生成在依赖实体之前供给依赖的 setup 代码
- **FR-007**: 系统必须生成按反向依赖顺序删除测试数据的 teardown 代码
- **FR-008**: 系统必须支持特定环境的蓝图（例如 staging vs production）
- **FR-009**: 系统必须与 e2e-test-generator 集成，将 fixture 导入和使用注入到生成的测试文件中
- **FR-010**: 系统必须在处理前使用 Zod schemas 验证蓝图模式
- **FR-011**: 系统必须支持基于 API 的数据供给的认证凭据（JWT、API keys）
- **FR-012**: 系统必须提供诊断命令来验证数据供给健康状况（例如检查 API 可达性、种子文件存在性）
- **FR-013**: 系统必须持久化数据来源元数据（哪些数据由哪个测试创建、何时创建、使用哪种策略）
- **FR-014**: 系统必须同时支持共享 fixtures（每个 worker 一个实例）和隔离 fixtures（每个测试一个）
- **FR-015**: 系统必须从蓝图模式生成 TypeScript 类型以实现类型安全的 fixture 使用
- **FR-016**: 系统必须支持蓝图版本控制以处理模式演化
- **FR-017**: 系统必须验证种子文件模式与蓝图定义匹配
- **FR-018**: 系统必须支持条件数据供给（例如仅在不存在时供给）
- **FR-019**: 系统必须记录所有数据供给操作及其时间戳和状态
- **FR-020**: 系统必须支持干运行模式以预览生命周期计划而不执行
- **FR-021**: 系统必须与 e2e-runner 集成以确保在测试执行前加载 fixtures
- **FR-022**: 系统必须提供 CLI 命令来脚手架新蓝图模板

### 核心实体 *(如果功能涉及数据)*

- **TestdataBlueprint（测试数据蓝图）**: 表示一个带有唯一 testdata_ref（例如 TD-ORDER-001）的数据契约，包含模式定义、依赖关系和供给策略配置。关键属性：id（testdata_ref）、schema（Zod schema）、dependencies（testdata_refs 列表）、strategy（seed/api/db-script）、metadata（环境、作用域）。

- **DataSupplyStrategy（数据供给策略）**: 定义如何供给测试数据。包括策略类型（seed/api/db-script）、配置（文件路径、API 端点、SQL 脚本）、认证详情和错误处理策略。关系：与 TestdataBlueprint 一对一。

- **LifecyclePlan（生命周期计划）**: 表示测试数据的 setup 和 teardown 序列。包括 setup 步骤（按依赖排序）、teardown 步骤（反向顺序）、作用域（test/worker/global）和执行状态。关系：从 TestdataBlueprint 和 DataSupplyStrategy 生成。

- **DataProvenance（数据来源）**: 跟踪测试数据实例的生命周期。包括数据 ID、testdata_ref、创建时间戳、使用的策略、测试 ID 和清理状态。用于调试和确保适当的 teardown。

## 成功标准 *(必填)*

### 可衡量结果

- **SC-001**: 测试开发者可以在 5 分钟内使用脚手架模板定义新的测试数据蓝图
- **SC-002**: 系统在 10 秒内验证包含 100+ 场景的测试套件中的所有 testdata_ref 引用
- **SC-003**: 生成的 Playwright fixtures 能编译且无 TypeScript 错误并通过严格类型检查
- **SC-004**: 95% 的数据供给失败提供带补救步骤的可操作错误消息
- **SC-005**: 生命周期计划能正确处理最多 5 层深的依赖链而无错误
- **SC-006**: 系统在测试执行前检测 100% 的循环依赖
- **SC-007**: 生成的 fixtures 支持并行测试执行而无数据冲突（当正确设置作用域时）
- **SC-008**: Teardown 代码能成功删除 99%+ 的测试数据而无需手动干预

## 假设 *(必填)*

1. **Playwright 框架**: 所有测试使用 Playwright 作为 E2E 测试框架
2. **TypeScript 代码库**: 测试代码用启用严格模式的 TypeScript 编写
3. **Supabase 后端**: 数据库操作使用 Supabase 客户端进行认证和数据访问
4. **YAML 蓝图格式**: 蓝图以 YAML 定义以提高可读性和易编辑性
5. **Git 仓库结构**: 蓝图存储在版本控制下的 `testdata/blueprints/` 目录
6. **环境隔离**: Staging 和 production 环境有独立的数据库和 API 端点
7. **认证可用**: 基于 API 的策略可以访问有效的认证令牌
8. **文件系统访问**: 种子文件可从测试运行器的文件系统访问
9. **Zod 验证**: 模式验证使用 Zod 库进行运行时类型检查
10. **CLI 调用**: 规划器通过 Claude Code skill 或命令行界面调用

## 依赖 *(如适用)*

- **test-scenario-author** (T001): 提供引用 testdata_refs 的测试场景 YAML 文件
- **e2e-test-generator** (T002): 消费生命周期计划以将 fixture 导入和使用注入到生成的 Playwright 测试中
- **e2e-runner** (T003): 执行带有供给 fixtures 的测试并报告数据供给失败
- **Playwright**: 提供 fixture 系统（test/worker/global 作用域）的测试框架
- **Zod**: 用于蓝图和策略验证的模式验证库
- **Supabase Client**: 用于 db-script 策略执行的数据库客户端
- **Node.js fs/promises**: 用于加载蓝图和种子文件的文件系统操作

## 不在范围内 *(如适用)*

- **可视化测试数据编辑器**: 无蓝图编辑 GUI；在 IDE 中编辑 YAML 即可
- **数据迁移工具**: 不支持在环境间迁移数据
- **性能测试数据**: 不专门支持大规模性能测试数据集
- **动态数据生成**: 无内置 Faker.js 或随机数据生成；使用种子文件或 API 响应
- **多租户数据隔离**: 假设单租户测试环境；无多租户支持
- **实时数据同步**: 不支持与生产数据库同步测试数据
- **数据匿名化**: 无 PII 清理或生产数据匿名化功能
- **快照测试**: 不支持跨测试运行捕获和比较数据快照

## 约束 *(如适用)*

- **蓝图文件大小**: 单个蓝图文件不得超过 1MB 以确保快速加载
- **依赖深度**: 依赖链不得超过 10 层以防止性能问题
- **种子文件大小**: 种子文件不应超过 10MB；更大的数据集必须使用 db-script 策略
- **API 超时**: 基于 API 的数据供给必须在 30 秒后超时以防止测试挂起
- **Fixture 作用域限制**: 全局 fixtures 必须谨慎使用（最多 5 个）以避免 setup 开销
- **命名约定**: Testdata_refs 必须遵循模式 `TD-<ENTITY>-<ID>`（例如 TD-ORDER-001）
- **环境配置**: 必须使用与 e2e-runner 配置相同的 env_profile 值
- **数据库权限**: db-script 策略必须使用读/写访问权限，而非超级用户权限
- **并行执行**: 共享 fixtures 必须是线程安全的以支持并行测试执行
- **TypeScript 版本**: 生成的代码必须与 TypeScript 5.x 兼容

## 风险 *(如适用)*

- **风险 1**: **依赖解析的复杂性** - 循环依赖或深层链可能难以调试。*缓解措施*: 实现清晰的验证错误和依赖图的可视化工具。
- **风险 2**: **环境特定失败** - API 端点或数据库脚本可能在 staging 中工作但在 CI 中失败。*缓解措施*: 提供诊断命令以在测试执行前预验证供给策略。
- **风险 3**: **不完整的 teardown** - 外键约束或业务逻辑可能阻止数据删除。*缓解措施*: 支持级联删除选项并记录 teardown 失败以便手动清理。
- **风险 4**: **认证令牌过期** - 长时间运行的测试套件可能在执行中遇到过期令牌。*缓解措施*: 在 API 策略 fixtures 中实现令牌刷新逻辑。
- **风险 5**: **数据版本漂移** - 蓝图模式可能随着后端 API 演化而过时。*缓解措施*: 添加模式版本控制并针对实时 API 响应进行验证。
- **风险 6**: **学习曲线** - 测试开发者可能发现蓝图/策略/生命周期概念复杂。*缓解措施*: 提供全面的文档、模板和示例。
- **风险 7**: **性能开销** - 为大型测试套件生成生命周期计划可能很慢。*缓解措施*: 缓存生成的计划并仅在蓝图更改时重新生成。
- **风险 8**: **跨技能协调** - 与 test-scenario-author、e2e-test-generator 和 e2e-runner 的紧密集成需要仔细的 API 设计。*缓解措施*: 定义清晰的契约和技能间的集成测试。

## 与现有技能的集成

### 工作流链

```
test-scenario-author (T001)
  ↓ (生成带 testdata_ref 的场景)
e2e-testdata-planner (T004) ← 当前位置
  ↓ (生成生命周期计划 + fixtures)
e2e-test-generator (T002)
  ↓ (生成带 fixture 导入的 .spec.ts)
e2e-runner (T003)
  ↓ (执行带供给数据的测试)
测试报告与诊断
```

### 关键集成点

1. **来自 test-scenario-author 的输入**: 从场景 YAML 文件读取 testdata_ref
2. **输出到 e2e-test-generator**: 提供 fixture 文件路径和导入语句
3. **输出到 e2e-runner**: 确保 fixtures 在 Playwright 配置中加载
4. **验证**: 验证场景中的所有 testdata_refs 都有对应的蓝图

### 蓝图文件位置

- **蓝图**: `testdata/blueprints/*.blueprint.yaml`
- **种子文件**: `testdata/seeds/*.json` 或 `*.yaml`
- **数据库脚本**: `testdata/scripts/*.sql`
- **生成的 fixtures**: `tests/fixtures/testdata/*.fixture.ts`（自动生成，请勿手动编辑）

## 备注

- 此技能专注于**契约定义和供给策略编排**，而非测试执行
- 生命周期计划是**代码生成产物**，而非运行时服务
- 规划器是**无状态的** - 它每次都从蓝图生成代码
- 数据来源跟踪是**可选的**，主要用于调试
- 蓝图验证应在**CI 流水线**中作为质量门禁运行，在测试执行前进行
